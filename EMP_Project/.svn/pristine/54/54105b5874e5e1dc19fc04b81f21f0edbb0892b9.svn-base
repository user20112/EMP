/*
 * mqtt.cpp
 *
 *  Created on: 18.09.2017
 *      Author: mario.richter
 */

#include "mqtt.h"

#include <time.h>
#include <stdexcept>
#include <iostream>


namespace UnloaderMqtt
{

// **************************************************************************************************
    // ** wrapper functions for callbacks
    // **************************************************************************************************
/*    void taskDisplayCallback(void *arg)
    {
    	mqtt* inst = reinterpret_cast<mqtt*>(arg);
        if (inst != nullptr)
            inst->taskDisplay();
    }
*/
    void mqttConnlostCallback(void *context, char *cause)
    {
    	mqtt* inst = reinterpret_cast<mqtt*>(context);
        if (inst != nullptr)
        {
            inst->mqttConnlost(context, cause);
        }
    }

    int mqttMsgArrvdCallback(void *context, char *topicName, int topicLen, MQTTClient_message *message)
    {
    	mqtt* inst = reinterpret_cast<mqtt*>(context);
        if (inst != nullptr)
            return inst->mqttMsgArrvd(context, topicName, topicLen, message);
        else
            return 1;
    }

    void mqttDeliveredCallback(void *context, MQTTClient_deliveryToken dt)
    {
    	mqtt* inst = reinterpret_cast<mqtt*>(context);
        if (inst != nullptr)
            inst->mqttDelivered(context, dt);
    }


  // **************************************************************************************************
  // ** mqtt constructor
  // **************************************************************************************************
  mqtt::mqtt(std::string _server, std::string _clientName)
  :server (_server),
   clientName (_clientName)
  {
    int result = 0;
    loggerName = "mqtt";
    SecsGemPanelId = "ERROR";	// wie bei Cognex
    SecsGemEquipmentName = "NULL";
    SecsGemTimeStamp = "NULL";
    newSecsGemPanelId = false;
    el::Loggers::getLogger(loggerName.c_str());

    CLOG(INFO, loggerName.c_str()) << "create MQTT client "<< clientName << " (connect to server: " << server << ")";

    result = MQTTClient_create(&client, server.append(":1883").c_str(), clientName.c_str(), MQTTCLIENT_PERSISTENCE_NONE, nullptr);
    //alt result = MQTTClient_setCallbacks(client, NULL, connlost, msgarrvd, delivered);
    result = MQTTClient_setCallbacks(client, (void*) this, mqttConnlostCallback, mqttMsgArrvdCallback, mqttDeliveredCallback);
    resetThreadPT(mWatchDogTask);
    mWatchDogWakeUp = PTHREAD_MUTEX_INITIALIZER;
    mWatchDocAbbort = false;

    pthread_mutex_lock(&mWatchDogWakeUp);
    result = pthread_create(&mWatchDogTask, NULL, startThread, (void*)this);
    if (result)
    {
      throw std::logic_error("create watchdog thread failed");
    }
  }

  // **************************************************************************************************
  // ** mqtt destructor
  // **************************************************************************************************
  mqtt::~mqtt()
  {
    CLOG(INFO, loggerName.c_str()) << "destroy MQTT client "<< clientName;
    pthread_mutex_unlock(&mWatchDogWakeUp);
    mWatchDocAbbort = true;
    pthread_join(mWatchDogTask, NULL);
    resetThreadPT(mWatchDogTask);

    MQTTClient_destroy(&client);
  }

  // **************************************************************************************************
  // ** sendMessage
  // **************************************************************************************************
  bool mqtt::sendMessage(std::string _topic, std::string _message)
  {
    if (MQTTClient_isConnected(client))
    {
      MQTTClient_message pubmsg = MQTTClient_message_initializer;
      MQTTClient_deliveryToken token;

      pubmsg.payload = (void*)_message.c_str();
      pubmsg.payloadlen = _message.size();
      pubmsg.retained = 0;

      MQTTClient_publishMessage(client, _topic.c_str(), &pubmsg, &token);
      return (true);
    }
    else
    {
      return (false);
    }
  }

  // **************************************************************************************************
  // ** watchDog
  // **************************************************************************************************
  void mqtt::watchDog(void)
  {
    int retryTime = 2;

    CLOG(INFO, loggerName.c_str()) << "monitoring of MQTT service connection started.";

    do
    {
      if (MQTTClient_isConnected(client))
      {
        retryTime = 2;
      }
      else
      {
        int rc;
        MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;
        conn_opts.keepAliveInterval = 20;
        conn_opts.cleansession = 1;

        if ((rc = MQTTClient_connect(client, &conn_opts)) != MQTTCLIENT_SUCCESS)
        {
          CLOG(ERROR, loggerName.c_str()) << "connect MQTT service failed: return code " << rc;
          retryTime = 5;
        }
        else
        {
          CLOG(INFO, loggerName.c_str()) << "MQTT service becomes alive again";
          retryTime = 2;
        }
      }

      // wait some time or until thread is waked up by parent
      struct timespec abs_time = {0};
      time_t timeNow = time(NULL);
      abs_time.tv_sec = timeNow + retryTime;

      pthread_mutex_timedlock(&mWatchDogWakeUp, &abs_time);
    } while (!mWatchDocAbbort);

    if (MQTTClient_isConnected(client))
    {
      MQTTClient_disconnect(client, 10000);
    }

    CLOG(INFO, loggerName.c_str()) << "monitoring of MQTT service connection stopped. Application is detached from service!";
  }

  // **************************************************************************************************
  // ** resetThreadPT
  // **************************************************************************************************
  void mqtt::resetThreadPT(pthread_t& _pt)
  {
    _pt = 0L;
  }

  // **************************************************************************************************
  // ** threatPTisNull
  // **************************************************************************************************
  bool mqtt::threatPTisNull (pthread_t& _pt)
  {
    return (_pt == 0L);
  }

  // **************************************************************************************************
  // ** isClientConnected
  // **************************************************************************************************
  bool mqtt::isClientConnected(void)
  {
    if(MQTTClient_isConnected(client))
      return true;
    else
      return false;
  }

  // **************************************************************************************************
  // ** startThread
  // **************************************************************************************************
  void* startThread(void *ptr)
  {
    if (ptr != nullptr)
    {
      mqtt* m = (mqtt*)(ptr);
      m->watchDog();
    }
    return (nullptr);
  }

  // **************************************************************************************************
  // ** delivered
  // **************************************************************************************************
  void mqtt::mqttDelivered(void *context, MQTTClient_deliveryToken dt)
  {
  }

  // **************************************************************************************************
  // ** msgarrvd
  // **************************************************************************************************
  int mqtt::mqttMsgArrvd(void *context, char *topicName, int topicLen, MQTTClient_message *message)
  {
      uint32_t columnIndex;

      json_t *root;
      json_error_t error;
      //char    *mqtt_payload;

      mqtt_error_connection = false;

      mqtt_telegram_timestamp = time(NULL);
      mqtt_telegram_counter++;

      CLOG(DEBUG, mLoggerName.c_str())<< "timestamp: " << time_hms
      << "strlen(payload): " << strlen((char*)message->payload)
      << " payloadlen: "<< message->payloadlen;

      root = json_loads((char*) message->payload, JSON_DISABLE_EOF_CHECK, &error);

      if (!root)
      {
          CLOG(DEBUG, mLoggerName.c_str())<< "ERROR: json_loads [" << error.line << "]->[" << error.text << "]"
          << "timestamp: " << time_hms
          << "strlen(payload): " << strlen((char*)message->payload)
          << " payloadlen: "<< message->payloadlen;

          MQTTClient_freeMessage(&message);
          MQTTClient_free(topicName);
          return(false);
      }

      if (!json_is_object(root))
      {
          CLOG(DEBUG, mLoggerName.c_str())<< "ERROR: !json_is_object(root)";
          json_decref(root);
          MQTTClient_freeMessage(&message);
          MQTTClient_free(topicName);
          return(false);
      }

      jsonName = json_object_get(root, "DefinitionId");
      if (!json_is_string(jsonName))
      {
          CLOG(DEBUG, mLoggerName.c_str())<< "ERROR: !json_is_string(jsonName)";
          json_decref(root);
          MQTTClient_freeMessage(&message);
          MQTTClient_free(topicName);
          return(false);
      }
      //syslog(LOG_ERR,"DEBUG: jsonName[%s]  %s,(%d)\n",json_string_value(jsonName), __FILE__, __LINE__);

      jsonVersion = json_object_get(root, "Version");
      if (!json_is_string(jsonVersion))
      {
          CLOG(DEBUG, mLoggerName.c_str())<< "ERROR: !json_is_string(jsonVersion)";
          json_decref(root);
          MQTTClient_freeMessage(&message);
          MQTTClient_free(topicName);
          return(false);
      }
      //syslog(LOG_ERR,"DEBUG: jsonVersion[%s]  %s,(%d)\n",json_string_value(jsonVersion), __FILE__, __LINE__);

      jsonColumns = json_object_get(root, "Columns");
      if (!json_is_object(jsonColumns))
      {
          CLOG(DEBUG, mLoggerName.c_str())<< "ERROR: !json_is_object(jsonColumns)";
          json_decref(root);
          MQTTClient_freeMessage(&message);
          MQTTClient_free(topicName);
          return(false);
      }

      for (columnIndex = 0; columnIndex < COLUMN_MAX_SIZE; columnIndex++)
      {
          jsonColumnValue[columnIndex] = json_object_get(jsonColumns, jsonColumnName[columnIndex]);
          if (!json_is_string(jsonColumnValue[columnIndex]))
          {
              CLOG(DEBUG, mLoggerName.c_str())<< "ERROR: !json_is_string(jsonColumnValue[columnIndex])";
              json_decref(jsonColumns);
              MQTTClient_freeMessage(&message);
              MQTTClient_free(topicName);
              return(false);
          }
          //syslog(LOG_ERR,"DEBUG: jsonColumnValue[%s]->[%s]  %s,(%d)\n", jsonColumnName[columnIndex], json_string_value(jsonColumnValue[columnIndex]), __FILE__, __LINE__);
      }
      if (json_string_value(jsonColumnValue[Panel]) != SecsGemPanelId)
      {
    	  // New ID received
    	  SecsGemPanelId		= json_string_value(jsonColumnValue[Panel]);					// Panel ID: 30E721808037001870000BT --> Nutzen ID ersetzt bisherigen Wert von Cognex Reader
    	  SecsGemEquipmentName	= json_string_value(jsonColumnValue[EquipmentName]);	// EquipmentName: HER-XLS-DammDisp105
    	  SecsGemTimeStamp		= json_string_value(jsonColumnValue[TS_SECS]);
    	  newSecsGemPanelId = true;

    	  CLOG(DEBUG, mLoggerName.c_str())<< "New PanelID(" << SecsGemPanelId << ") EquipmentName: " << SecsGemEquipmentName << " Time: " << SecsGemTimeStamp;
      }
      else
      {
    	  // Duplicated ID received
    	  // sollte nicht vorkommen, weil Topic update nur bei Änderung kommt
    	  // fals es trotzdem kommt, wurde was falsches von SECS Gem eingetragen!
    	  CLOG(DEBUG, mLoggerName.c_str())<< "ERROR: Duplicated PanelID (" << json_string_value(jsonColumnValue[Panel]) <<") Time: " << json_string_value(jsonColumnValue[TS_SECS]) << " EquipmentName: " << json_string_value(jsonColumnValue[EquipmentName]);
      }

      MQTTClient_freeMessage(&message);
      MQTTClient_free(topicName);
      return (true);
  }

  // **************************************************************************************************
  // ** connlost
  // **************************************************************************************************
  void mqtt::mqttConnlost(void *context, char *cause)
  {
    if (cause != nullptr)
      std::cerr << "connect MQTT service lost: \"" << cause << "\"" << std::endl;
    else
      std::cerr << "connect MQTT service lost: unknown reason" << std::endl;
  }

}


